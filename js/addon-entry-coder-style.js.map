{"version":3,"file":"js/addon-entry-coder-style.js","sources":["webpack://GUI/./src/addons/addons/coder-style/coder-style.css","webpack://GUI/./src/addons/addons/coder-style/_runtime_entry.js","webpack://GUI/./src/addons/addons/coder-style/userscript.js"],"sourcesContent":["exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/* 积木主体路径极低透明度 */\\n.blocklySvg > .blocklyWorkspace > .blocklyBlockCanvas > .blocklyDraggable .blocklyPath {\\n  opacity: var(--coder-style-block-opacity, 0.02) !important;\\n}\\n\\n/* 积木文字显示分类颜色 */\\n.blocklyText {\\n  fill: currentColor !important;\\n}\\n\\n/* 拖拽时的积木保持可见 */\\n.blocklyBlockDragSurface .blocklyPath {\\n  opacity: 0.3 !important;\\n}\\n\\n/* 悬停时的积木稍微可见 */\\n.blocklyDraggable:hover .blocklyPath {\\n  opacity: calc(var(--coder-style-block-opacity, 0.02) * 2) !important;\\n}\\n\\n/* 选中状态的积木稍微可见 */\\n.blocklySelected .blocklyPath {\\n  opacity: 0.05 !important;\\n}\\n\\n/* 飞出面板中的积木稍微可见 */\\n.blocklyFlyout > .blocklyWorkspace > .blocklyBlockCanvas > .blocklyDraggable .blocklyPath {\\n  opacity: 0.04 !important;\\n}\\n\\n/* 确保积木连接点保持可见 */\\n.blocklyPath.blocklyNotch {\\n  opacity: 0.1 !important;\\n}\\n\\n/* 确保 SVG 元素可交互 */\\n.blocklySvg > .blocklyWorkspace > .blocklyBlockCanvas > .blocklyDraggable {\\n  pointer-events: auto !important;\\n}\", \"\"]);\n\n// exports\n","import _js from \"./userscript.js\";\nimport _css from \"!css-loader!./coder-style.css\";\n\nexport const resources = {\n  \"userscript.js\": _js,\n  \"coder-style.css\": _css\n};","export default async function ({ addon, console, msg }) {\n  const Blockly = await addon.tab.traps.getBlockly();\n\n  // 获取透明度设置\n  const getBlockOpacity = () => addon.settings.get(\"block-opacity\") || 0.02;\n  const getCShapeOpacity = () => addon.settings.get(\"c-shape-opacity\") || 0.08;\n  const getBooleanOpacity = () => addon.settings.get(\"boolean-opacity\") || 0.15;\n  const getInputOpacity = () => addon.settings.get(\"input-opacity\") || 0.12;\n\n  // 判断积木类型\n  const isRoundBlock = (block) => block.outputShape_ === Blockly.OUTPUT_SHAPE_ROUND;\n  const isHexagonBlock = (block) => block.outputShape_ === Blockly.OUTPUT_SHAPE_HEXAGONAL;\n  const isSquareInputBlock = (block) => block.outputShape_ === Blockly.OUTPUT_SHAPE_SQUARE && !block.outputConnection;\n  const needsLeftBorder = (block) => !isRoundBlock(block) && !isHexagonBlock(block) && !isSquareInputBlock(block);\n\n  // 清理积木的装饰元素\n  const clearBlockDecorations = (block) => {\n    if (block.coderStyleDecorations_) {\n      block.coderStyleDecorations_.forEach(el => el.remove());\n      block.coderStyleDecorations_ = null;\n    }\n  };\n\n  // 为圆形积木创建左右圆角弧线，类似 (  )\n  const createRoundDecorations = (block, color, height, width) => {\n    const svgGroup = block.getSvgRoot();\n    const pathElement = block.svgPath_;\n    if (!pathElement) return [];\n\n    const decorations = [];\n    // 圆角半径与积木高度匹配，使用高度的40%\n    const cornerRadius = height;\n    const strokeWidth = 0;\n\n    // 左圆角弧线 - 往外凸，使用 A 命令，类似 (\n    const leftArc = Blockly.utils.createSvgElement(\"path\", {\n      d: `M ${cornerRadius/2} ${cornerRadius} A ${height/2} ${height/2} 0 0 1 ${cornerRadius/2} ${height - cornerRadius}`,\n      fill: \"none\",\n      stroke: color,\n      \"stroke-width\": 2,\n      \"stroke-linecap\": \"round\"\n    });\n    decorations.push(leftArc);\n\n    // 右圆角弧线 - 往外凸，使用 A 命令，类似 )\n    const rightArc = Blockly.utils.createSvgElement(\"path\", {\n      d: `M ${width - cornerRadius/2} ${cornerRadius} A ${height/2} ${height/2} 0 0 0 ${width - cornerRadius/2} ${height - cornerRadius}`,\n      fill: \"none\",\n      stroke: color,\n      \"stroke-width\": 2,\n      \"stroke-linecap\": \"round\"\n    });\n    decorations.push(rightArc);\n\n    // 将所有装饰添加到 SVG 组中，放在路径之前\n    decorations.forEach(decoration => {\n      svgGroup.insertBefore(decoration, pathElement);\n    });\n\n    return decorations;\n  };\n\n  // 为六边形积木创建左右棱角，类似 <>\n  const createHexagonDecorations = (block, color, height, width) => {\n    const svgGroup = block.getSvgRoot();\n    const pathElement = block.svgPath_;\n    if (!pathElement) return [];\n\n    const decorations = [];\n    // 棱角大小与积木高度匹配，使用高度的30%\n    const cornerSize = height;\n    const strokeWidth = 2;\n\n    // 左棱角 - 45度，形成 <\n    const leftCorner = Blockly.utils.createSvgElement(\"path\", {\n      d: `M ${cornerSize/2} ${cornerSize} L ${0} ${height / 2} L ${cornerSize/2} ${height  - cornerSize}`,\n      fill: \"none\",\n      stroke: color,\n      \"stroke-width\": strokeWidth,\n      \"stroke-linecap\": \"round\",\n      \"stroke-linejoin\": \"round\"\n    });\n    decorations.push(leftCorner);\n\n    // 右棱角 - 45度，形成 >\n    const rightCorner = Blockly.utils.createSvgElement(\"path\", {\n      d: `M ${width-cornerSize/2} ${cornerSize} L ${width} ${height / 2} L ${width-cornerSize/2} ${height- cornerSize}`,\n      fill: \"none\",\n      stroke: color,\n      \"stroke-width\": strokeWidth,\n      \"stroke-linecap\": \"round\",\n      \"stroke-linejoin\": \"round\"\n    });\n    decorations.push(rightCorner);\n\n    // 将所有装饰添加到 SVG 组中，放在路径之前\n    decorations.forEach(decoration => {\n      svgGroup.insertBefore(decoration, pathElement);\n    });\n\n    return decorations;\n  };\n\n  // 为积木添加或更新左端竖线（普通积木）\n  const updateLeftBorder = (block) => {\n    if (!needsLeftBorder(block)) {\n      if (block.coderStyleLeftBorder_) {\n        block.coderStyleLeftBorder_.remove();\n        block.coderStyleLeftBorder_ = null;\n      }\n      return;\n    }\n\n    const color = block.getColour();\n    const svgGroup = block.getSvgRoot();\n    const pathElement = block.svgPath_;\n    if (!pathElement) return;\n\n    const height = block.height;\n    const width = block.width;\n\n    if (block.coderStyleLeftBorder_) {\n      block.coderStyleLeftBorder_.setAttribute(\"stroke\", color);\n      block.coderStyleLeftBorder_.setAttribute(\"x1\", 0);\n      block.coderStyleLeftBorder_.setAttribute(\"x2\", 0);\n      block.coderStyleLeftBorder_.setAttribute(\"y1\", 0);\n      block.coderStyleLeftBorder_.setAttribute(\"y2\", height);\n      return;\n    }\n\n    const line = Blockly.utils.createSvgElement(\"line\", {\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: height,\n      stroke: color,\n      \"stroke-width\": 2,\n      \"stroke-linecap\": \"round\"\n    });\n\n    svgGroup.insertBefore(line, pathElement);\n    block.coderStyleLeftBorder_ = line;\n  };\n\n  // 更新积木的装饰元素\n  const updateBlockDecorations = (block) => {\n    clearBlockDecorations(block);\n\n    const color = block.getColour();\n    const height = block.height;\n    const width = block.width;\n\n    if (isRoundBlock(block)) {\n      block.coderStyleDecorations_ = createRoundDecorations(block, color, height, width);\n    } else if (isHexagonBlock(block)) {\n      block.coderStyleDecorations_ = createHexagonDecorations(block, color, height, width);\n    } else {\n      updateLeftBorder(block);\n    }\n  };\n\n  // Patch FieldLabel.prototype.init 设置文字颜色\n  const oldFieldLabelInit = Blockly.FieldLabel.prototype.init;\n  Blockly.FieldLabel.prototype.init = function () {\n    oldFieldLabelInit.call(this);\n    if (!addon.self.disabled) {\n      const block = this.sourceBlock_;\n      if (block) {\n        const color = block.getColourTertiary();\n        this.textElement_.style.setProperty(\"fill\", color, \"important\");\n      }\n    }\n  };\n\n  // Patch FieldVariableGetter.prototype.init 设置变量积木文字颜色\n  const oldFieldVariableGetterInit = Blockly.FieldVariableGetter.prototype.init;\n  Blockly.FieldVariableGetter.prototype.init = function () {\n    oldFieldVariableGetterInit.call(this);\n    if (!addon.self.disabled) {\n      const block = this.sourceBlock_;\n      if (block) {\n        const color = block.getColourTertiary();\n        this.textElement_.style.setProperty(\"fill\", color, \"important\");\n      }\n    }\n  };\n\n  // Patch BlockSvg.prototype.render 更新积木装饰\n  const oldBlockRender = Blockly.BlockSvg.prototype.render;\n  Blockly.BlockSvg.prototype.render = function (opt_bubble) {\n    oldBlockRender.call(this, opt_bubble);\n    if (!addon.self.disabled) {\n      updateBlockDecorations(this);\n    }\n  };\n\n  // Patch BlockSvg.prototype.updateColour 设置积木透明度\n  const oldBlockUpdateColour = Blockly.BlockSvg.prototype.updateColour;\n  Blockly.BlockSvg.prototype.updateColour = function () {\n    oldBlockUpdateColour.call(this);\n    if (!addon.self.disabled && this.svgPath_) {\n      const color = this.getColour();\n\n      let opacity = getBlockOpacity();\n\n      if (isHexagonBlock(this)) {\n        opacity = getBooleanOpacity();\n        this.svgPath_.style.opacity = opacity;\n      } else if (isRoundBlock(this)) {\n        opacity = getInputOpacity();\n        this.svgPath_.style.opacity = opacity;\n      } else if (isSquareInputBlock(this)) {\n        opacity = getInputOpacity();\n        this.svgPath_.style.stroke = color;\n        this.svgPath_.style.strokeWidth = '1px';\n        this.svgPath_.style.opacity = opacity;\n      } else if (this.inputList.some(input => input.type === Blockly.INPUT_STATEMENT)) {\n        opacity = getCShapeOpacity();\n        this.svgPath_.style.opacity = opacity;\n      } else {\n        this.svgPath_.style.opacity = opacity;\n      }\n\n      // 更新装饰颜色\n      if (this.coderStyleDecorations_) {\n        this.coderStyleDecorations_.forEach(el => {\n          el.setAttribute(\"stroke\", color);\n        });\n      }\n\n      // 更新左端竖线颜色\n      if (this.coderStyleLeftBorder_) {\n        this.coderStyleLeftBorder_.setAttribute(\"stroke\", color);\n      }\n    }\n  };\n\n  // 监听积木销毁事件，清理装饰元素\n  const oldBlockDispose = Blockly.BlockSvg.prototype.dispose;\n  Blockly.BlockSvg.prototype.dispose = function () {\n    clearBlockDecorations(this);\n    if (this.coderStyleLeftBorder_) {\n      this.coderStyleLeftBorder_.remove();\n      this.coderStyleLeftBorder_ = null;\n    }\n    oldBlockDispose.call(this);\n  };\n\n  // 监听设置变化\n  addon.settings.addEventListener(\"change\", () => {\n    Blockly.getMainWorkspace().getAllBlocks().forEach(block => {\n      block.updateColour();\n    });\n  });\n}"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}